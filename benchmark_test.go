package main

import (
	"bufio"
	"bytes"
	"compress/gzip"
	"encoding/json"
	"os"
	"reflect"
	"testing"

	"github.com/bytedance/sonic"
)

var benchmarkData []byte
var benchmarkTree *TreeNode

func init() {
	// Read the test data file generated by main.go
	var err error
	benchmarkData, err = os.ReadFile("test_data.json")
	if err != nil {
		panic(err)
	}

	// Unmarshal the data for decoding benchmarks
	benchmarkTree = &TreeNode{}
	err = json.Unmarshal(benchmarkData, benchmarkTree)
	if err != nil {
		panic(err)
	}

	// Pretouch the struct for better Sonic performance
	err = sonic.Pretouch(reflect.TypeOf(TreeNode{}))
	if err != nil {
		panic(err)
	}
}

// BenchmarkStdlibEncoding tests the performance of JSON encoding using stream API
func BenchmarkStdlibEncoding(b *testing.B) {
	// Set the number of bytes processed in each operation
	b.SetBytes(int64(len(benchmarkData)))

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		// Use a buffer for encoding
		buf := &bytes.Buffer{}
		encoder := json.NewEncoder(buf)
		err := encoder.Encode(benchmarkTree)
		if err != nil {
			b.Fatal(err)
		}
		_ = buf // Prevent compiler optimization
	}
}

// BenchmarkStdlibDecoding tests the performance of JSON decoding using stream API
func BenchmarkStdlibDecoding(b *testing.B) {
	// Set the number of bytes processed in each operation
	b.SetBytes(int64(len(benchmarkData)))

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		var tree TreeNode
		buf := bytes.NewBuffer(benchmarkData)
		decoder := json.NewDecoder(buf)
		err := decoder.Decode(&tree)
		if err != nil {
			b.Fatal(err)
		}
	}
}

// BenchmarkStdlibEncodingCompressed tests the performance of JSON encoding with gzip compression
func BenchmarkStdlibEncodingCompressed(b *testing.B) {
	// Set the number of bytes processed in each operation
	b.SetBytes(int64(len(benchmarkData)))

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		// Use a buffer for encoding
		buf := &bytes.Buffer{}
		// Use default compression level
		gzipWriter := gzip.NewWriter(buf)
		encoder := json.NewEncoder(gzipWriter)
		err := encoder.Encode(benchmarkTree)
		if err != nil {
			b.Fatal(err)
		}
		// Close the gzip writer to flush any remaining data
		err = gzipWriter.Close()
		if err != nil {
			b.Fatal(err)
		}
		_ = buf // Prevent compiler optimization
	}
}

// BenchmarkStdlibDecodingCompressed tests the performance of JSON decoding with gzip decompression
func BenchmarkStdlibDecodingCompressed(b *testing.B) {
	// First, compress the benchmark data with default compression level
	var compressedData bytes.Buffer
	gzipWriter := gzip.NewWriter(&compressedData)
	_, err := gzipWriter.Write(benchmarkData)
	if err != nil {
		b.Fatal(err)
	}
	err = gzipWriter.Close()
	if err != nil {
		b.Fatal(err)
	}

	// Set the number of bytes processed in each operation
	b.SetBytes(int64(len(benchmarkData)))

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		var tree TreeNode
		// Use a bytes.Reader instead of bytes.Buffer for better performance
		reader := bytes.NewReader(compressedData.Bytes())
		gzipReader, err := gzip.NewReader(reader)
		if err != nil {
			b.Fatal(err)
		}
		// Wrap the gzip reader with a bufio.Reader for better I/O performance
		bufioReader := bufio.NewReaderSize(gzipReader, 64*1024) // 64KB buffer
		decoder := json.NewDecoder(bufioReader)
		err = decoder.Decode(&tree)
		if err != nil {
			b.Fatal(err)
		}
		// Close the gzip reader
		err = gzipReader.Close()
		if err != nil {
			b.Fatal(err)
		}
	}
}

// BenchmarkSonicEncoding tests the performance of Sonic JSON encoding using stream API
func BenchmarkSonicEncoding(b *testing.B) {
	// Set the number of bytes processed in each operation
	b.SetBytes(int64(len(benchmarkData)))

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		// Use a buffer for encoding
		buf := &bytes.Buffer{}
		encoder := sonic.ConfigDefault.NewEncoder(buf)
		err := encoder.Encode(benchmarkTree)
		if err != nil {
			b.Fatal(err)
		}
		_ = buf // Prevent compiler optimization
	}
}

// BenchmarkSonicDecoding tests the performance of Sonic JSON decoding using stream API
func BenchmarkSonicDecoding(b *testing.B) {
	// Set the number of bytes processed in each operation
	b.SetBytes(int64(len(benchmarkData)))

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		var tree TreeNode
		buf := bytes.NewBuffer(benchmarkData)
		decoder := sonic.ConfigDefault.NewDecoder(buf)
		err := decoder.Decode(&tree)
		if err != nil {
			b.Fatal(err)
		}
	}
}

// BenchmarkSonicEncodingCompressed tests the performance of Sonic JSON encoding with gzip compression
func BenchmarkSonicEncodingCompressed(b *testing.B) {
	// Set the number of bytes processed in each operation
	b.SetBytes(int64(len(benchmarkData)))

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		// Use a buffer for encoding
		buf := &bytes.Buffer{}
		// Use default compression level
		gzipWriter := gzip.NewWriter(buf)
		// Use ConfigFastest for faster encoding
		encoder := sonic.ConfigFastest.NewEncoder(gzipWriter)
		err := encoder.Encode(benchmarkTree)
		if err != nil {
			b.Fatal(err)
		}
		// Close the gzip writer to flush any remaining data
		err = gzipWriter.Close()
		if err != nil {
			b.Fatal(err)
		}
		_ = buf // Prevent compiler optimization
	}
}

// BenchmarkSonicDecodingCompressed tests the performance of Sonic JSON decoding with gzip decompression
// Uses streaming approach to demonstrate performance issue with compressed data
func BenchmarkSonicDecodingCompressed(b *testing.B) {
	// First, compress the benchmark data with default compression level
	var compressedData bytes.Buffer
	gzipWriter := gzip.NewWriter(&compressedData)
	_, err := gzipWriter.Write(benchmarkData)
	if err != nil {
		b.Fatal(err)
	}
	err = gzipWriter.Close()
	if err != nil {
		b.Fatal(err)
	}

	// Set the number of bytes processed in each operation
	b.SetBytes(int64(len(benchmarkData)))

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		var tree TreeNode
		// Use a bytes.Reader instead of bytes.Buffer for better performance
		reader := bytes.NewReader(compressedData.Bytes())
		gzipReader, err := gzip.NewReader(reader)
		if err != nil {
			b.Fatal(err)
		}
		// Wrap the gzip reader with a bufio.Reader for better I/O performance
		bufioReader := bufio.NewReaderSize(gzipReader, 64*1024) // 64KB buffer
		decoder := sonic.ConfigDefault.NewDecoder(bufioReader)
		err = decoder.Decode(&tree)
		if err != nil {
			b.Fatal(err)
		}
		// Close the gzip reader
		err = gzipReader.Close()
		if err != nil {
			b.Fatal(err)
		}
	}
}
